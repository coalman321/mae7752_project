#include <memory>
#include <thread>

#include <rclcpp/rclcpp.hpp>

#include <geometry_msgs/msg/pose.hpp>
#include <moveit_msgs/msg/robot_trajectory.hpp>

#include <moveit/move_group_interface/move_group_interface.h>
#include <moveit_visual_tools/moveit_visual_tools.h>

namespace rvt = rviz_visual_tools;

/*
The plan:
1. Take in a set of points, start and end of the 2d path
2. Hand the points to the RRT* planner system and get a path back
3. Feed it to the MoveIT IK system
4. Feed the MoveIT IK solution to the robot and execute it

working from these sources 
http://docs.ros.org/en/kinetic/api/moveit_tutorials/html/doc/move_group_interface/move_group_interface_tutorial.html#cartesian-paths
https://moveit.picknik.ai/humble/doc/tutorials/your_first_project/your_first_project.html
*/

class IKExecutorNode: public rclcpp::Node{
  public:
  IKExecutorNode(): Node("ik_executor"){
    // Declare planning group name parameter
    declare_parameter<std::string>("planning_group", "ur5e");

    // Declare end effector link name
    declare_parameter<std::string>("end_link", "eff");
    declare_parameter<std::string>("base_link", "ur5e_base");

    // Declare start point parameters 


    // Declare end point parameters


    // Declare table offset height parameter


    // Declare timing parameters

    // Create the moveit instance
    using moveit::planning_interface::MoveGroupInterface;
    plan_grp_name_ = get_parameter("planning_group").as_string();
    mv_grp_interf_ = std::make_shared<MoveGroupInterface>(this->shared_from_this(), plan_grp_name_);

    // create the visualizer instance
    const auto baseName = get_parameter("base_link").as_string();
    viz_tools_ = std::make_shared<moveit_visual_tools::MoveItVisualTools>(this->shared_from_this(), baseName);
    viz_tools_->loadRemoteControl();

    // put a default visualization message in
    text_pose_.position.z = 2.5;
    viz_tools_->publishText(text_pose_, "MoveGroupInterface Demo", rvt::WHITE, rvt::XLARGE);
    viz_tools_->trigger();

    // create and start the runner thread
    plan_runner_thread_ = std::thread{std::bind(&IKExecutorNode::planRun, this)};
    plan_runner_thread_.detach();
  }

  void planRun(){
    // Retrieve the set of points
    geometry_msgs::msg::Pose startingPose;
    startingPose.orientation.w = 1.0;
    startingPose.position.x = 0.28;
    startingPose.position.y = -0.2;
    startingPose.position.z = 0.5;

    geometry_msgs::msg::Pose endingPose;
    endingPose.orientation.w = 1.0;
    endingPose.position.x = 0.28;
    endingPose.position.y = -0.2;
    endingPose.position.z = 0.5;

    // Record the starting pose of the robot to return to later
    end_link_name_ = get_parameter("end_link").as_string();
    const auto initalPose = mv_grp_interf_->getCurrentPose(end_link_name_).pose;

    // make the three stage trajectory
    std::vector<geometry_msgs::msg::Pose> waypoints, plannerPoints;
    
    
    // Stage 1: lift the cup
    waypoints.push_back(startingPose);

    // Stage 2: move the cup through the path generated by the planner
    waypoints.insert(waypoints.end(), plannerPoints.begin(), plannerPoints.end());

    // Stage 3: lower the cup to the table
    waypoints.push_back(endingPose);


    // Send the points into moveit
    moveit_msgs::msg::RobotTrajectory trajectory;
    const double jump_threshold = 0.1; // this can cause big moves for physical hardware if zero
    const double eef_step = 0.01;
    double fraction = mv_grp_interf_->computeCartesianPath(waypoints, eef_step, jump_threshold, trajectory);
    RCLCPP_INFO(get_logger(), "path planned successfully (%.2f%% acheived)", fraction * 100.0);


    // exceute plan from starting pose to path starting point
    bool success = moveToPoint(startingPose);
    if(! success){
      RCLCPP_ERROR(get_logger(), "Failed to move robot to starting point");
      return;
    }

    // wait for gripper to close

    // execute cup move plan

    // wait for gripper to open

    // execute plan from path end point back to robot starting pose
    success = moveToPoint(initalPose);
    if(! success){
      RCLCPP_ERROR(get_logger(), "Failed to move robot back to intiial pose");
      return;
    }
  }

  bool moveToPoint(geometry_msgs::msg::Pose target_pose){
    // Set a target Pose into moveit
    mv_grp_interf_->setPoseTarget(target_pose);

    // Create a plan to the target pose
    moveit::planning_interface::MoveGroupInterface::Plan msg;
    auto planStatus = mv_grp_interf_->plan(msg);


    
    if(static_cast<bool>(planStatus)){
      const auto initalPose = mv_grp_interf_->getCurrentPose(end_link_name_).pose;

      // Display the plan in RVIZ
      const auto jmg = mv_grp_interf_->getCurrentState()->getJointModelGroup(plan_grp_name_);
      viz_tools_->deleteAllMarkers();
      viz_tools_->publishAxisLabeled(initalPose, "start");
      viz_tools_->publishAxisLabeled(target_pose, "goal");
      viz_tools_->publishTrajectoryLine(msg.trajectory_, jmg);
      viz_tools_->trigger();
      viz_tools_->prompt("Execute?");

      // Execute the plan if it was able to make a plan
      auto executeStatus = mv_grp_interf_->execute(msg);

      // return true if the error code is okay
      if(static_cast<bool>(executeStatus)){
        return true;
      } else {
        // Show an error if the execution failed
        RCLCPP_ERROR_STREAM(get_logger(), "Execution of path failed with status: " << executeStatus.val);
      }
    } else {
      // Show an error for a planning failure
      RCLCPP_ERROR_STREAM(get_logger(), "Planning of path failed with status: " << planStatus.val);
    }

    // we failed somewhere during the routine
    return false;
  }

  /*
  viz_tools_->deleteAllMarkers();
      viz_tools_->publishText(text_pose, "Joint Space Goal", rvt::WHITE, rvt::XLARGE);
      viz_tools->publishPath(waypoints, rvt::LIME_GREEN, rvt::SMALL);
      for (std::size_t i = 0; i < waypoints.size(); ++i)
        viz_tools->publishAxisLabeled(waypoints[i], "pt" + std::to_string(i), rvt::SMALL);
      viz_tools->trigger();
      viz_tools->prompt("Press 'next' in the RvizVisualToolsGui window to continue the demo");
  */

  private:
    // end effector link name
    std::string end_link_name_;
    std::string plan_grp_name_;

    // execution thread
    std::thread plan_runner_thread_;

    // moveit instance
    std::shared_ptr<moveit::planning_interface::MoveGroupInterface> mv_grp_interf_;

    // moveit visualization tools
    std::shared_ptr<moveit_visual_tools::MoveItVisualTools> viz_tools_;
    geometry_msgs::msg::Pose text_pose_;

};


int main(int argc, char** argv) {
  // init ros node
  rclcpp::init(argc, argv);

  // Create the node and spin it 
  auto driver = std::make_shared<IKExecutorNode>();
  rclcpp::spin(driver);

  // the node has been called to shutdown, so rclcpp needs to be shut down as well
  rclcpp::shutdown();
  return 0;
}
